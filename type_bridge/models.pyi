# Type stubs for models.py to help Pyright understand Entity/Relation __init__ signatures

from datetime import datetime as datetime_type
from typing import Any, ClassVar, overload
from type_bridge.attribute import Attribute, AttributeFlags, EntityFlags, RelationFlags

class Entity:
    """Type stub that tells Pyright about flexible __init__ signatures."""

    _flags: ClassVar[EntityFlags]
    _owned_attrs: ClassVar[dict[str, dict[str, Any]]]
    _iid: str | None

    # Tell Pyright that __init__ accepts flexible types based on annotations
    # This is a lie for the type checker - actual signature is generated by Pydantic
    def __init__(self, **kwargs: Any) -> None: ...

    @classmethod
    def get_type_name(cls) -> str: ...

    @classmethod
    def get_supertype(cls) -> str | None: ...

    @classmethod
    def is_abstract(cls) -> bool: ...

    @classmethod
    def get_owned_attributes(cls) -> dict[str, dict[str, Any]]: ...

    @classmethod
    def to_schema_definition(cls) -> str: ...

    def to_insert_query(self, var: str = "$e") -> str: ...


class Role:
    role_name: str
    player_type: str
    attr_name: str | None

    def __init__(self, role_name: str, player_type: str | type) -> None: ...


class Relation:
    """Type stub for Relation class."""

    _flags: ClassVar[RelationFlags]
    _owned_attrs: ClassVar[dict[str, dict[str, Any]]]
    _roles: ClassVar[dict[str, Role]]
    _iid: str | None

    # Flexible __init__ like Entity
    def __init__(self, **kwargs: Any) -> None: ...

    @classmethod
    def get_type_name(cls) -> str: ...

    @classmethod
    def get_supertype(cls) -> str | None: ...

    @classmethod
    def is_abstract(cls) -> bool: ...

    @classmethod
    def get_owned_attributes(cls) -> dict[str, dict[str, Any]]: ...

    @classmethod
    def to_schema_definition(cls) -> str: ...
